{
  "version": 3,
  "sources": ["../../graphql-ast-types-browser/src/definitions/index.js", "../../graphql-ast-types-browser/src/definitions/graphql.js", "../../graphql-ast-types-browser/src/definitions/init.js", "../../graphql-ast-types-browser/src/index.js", "../../ra-data-graphql-simple/src/index.ts", "../../ra-data-graphql-simple/src/getFinalType.ts", "../../ra-data-graphql-simple/src/isList.ts", "../../ra-data-graphql-simple/src/buildVariables.ts", "../../ra-data-graphql-simple/src/buildGqlQuery.ts", "../../ra-data-graphql-simple/src/isRequired.ts", "../../ra-data-graphql-simple/src/getResponseParser.ts", "../../ra-data-graphql-simple/src/buildQuery.ts"],
  "sourcesContent": ["// @flow\nconst t = require(\"../index\");\n\ntype Validator = {\n  validate: Function,\n  optional?: boolean\n};\n\nexport const BUILDER_KEYS: { [type: string]: Array<string> } = {};\nexport const NODE_FIELDS: {\n  [type: string]: { [fieldKey: string]: Validator }\n} = {};\nexport const ALIAS_KEYS: { [type: string]: Array<string> } = {};\n\ntype Option = {\n  fields?: { [fieldKey: string]: Validator },\n  aliases?: Array<string>,\n  builder?: Array<string> // Node properties to be transformed into params\n};\n\n/**\n * Used to define an AST node.\n * @param {String} type The AST node name\n * @param {Object} opts Type definition object\n * @returns {void}\n */\nexport default function defineType(\n  type: string,\n  { fields = {}, aliases = [], builder = [] }: Option = {}\n) {\n  for (const key in fields) {\n    const field = fields[key];\n\n    // Sets field as optional if builder exist but validator does not.\n    if (builder.indexOf(key) === -1) {\n      field.optional = true;\n    }\n  }\n\n  BUILDER_KEYS[type] = builder;\n  NODE_FIELDS[type] = fields;\n  ALIAS_KEYS[type] = aliases;\n}\n\nfunction getType(val) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else if (val === undefined) {\n    return \"undefined\";\n  } else {\n    return typeof val;\n  }\n}\n\n// Validation helpers\n\nexport function chain(...fns: Array<Function>): Function {\n  return function validate(...args) {\n    fns.forEach(fn => fn(...args));\n  };\n}\n\nexport function assertEach(callback: Function): Function {\n  function validator(node, key, val) {\n    if (!Array.isArray(val)) {\n      return;\n    }\n\n    val.forEach((it, i) => callback(node, `${key}[${i}]`, it));\n  }\n  return validator;\n}\n\nexport function assertOneOf(...vals: Array<string>): Function {\n  function validate(node, key, val) {\n    if (vals.indexOf(val.kind) < 0) {\n      throw new TypeError(\n        `Property ${key} expected value to be one of ${JSON.stringify(\n          vals\n        )} but got ${JSON.stringify(val)}`\n      );\n    }\n  }\n\n  return validate;\n}\n\nexport function assertNodeType(...types: Array<string>): Function {\n  function validate(node, key, val) {\n    const valid = types.every(type => t.is(type, val));\n\n    if (!valid) {\n      throw new TypeError(\n        `Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(\n          types\n        )} ` + `but instead got ${JSON.stringify(val && val.type)}`\n      );\n    }\n  }\n\n  return validate;\n}\n\nexport function assertNodeOrValueType(...types: Array<string>): Function {\n  function validate(node, key, val) {\n    const valid = types.every(type => getType(val) === type || t.is(type, val));\n\n    if (!valid) {\n      throw new TypeError(\n        `Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(\n          types\n        )} ` + `but instead got ${JSON.stringify(val && val.type)}`\n      );\n    }\n  }\n\n  return validate;\n}\n\nexport function assertValueType(type: string): Function {\n  function validate(node, key, val) {\n    const valid = getType(val) === type;\n\n    if (!valid) {\n      throw new TypeError(\n        `Property ${key} expected type of ${type} but got ${getType(val)}`\n      );\n    }\n  }\n\n  return validate;\n}\n\nexport function assertArrayOf(cb: Function): Function {\n  return chain(assertValueType(\"array\"), assertEach(cb));\n}\n", "/* These are auto-generated definitions: Please do not edit this file directly */\n\nimport {\n  assertNodeType,\n  assertValueType,\n  assertEach,\n  assertOneOf,\n  assertArrayOf\n} from './index';\n\nexport default () => [[\"Name\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      optional: false,\n      validate: assertValueType(\"string\")\n    }\n  },\n  aliases: [\"AST\"]\n}], [\"Document\", {\n  builder: [\"definitions\"],\n  fields: {\n    definitions: {\n      optional: false,\n      validate: assertArrayOf(assertNodeType(\"Definition\"))\n    }\n  },\n  aliases: [\"AST\"]\n}], [\"OperationDefinition\", {\n  builder: [\"operation\", \"selectionSet\", \"name\", \"variableDefinitions\", \"directives\"],\n  fields: {\n    operation: {\n      optional: false,\n      validate: assertValueType(\"string\")\n    },\n    selectionSet: {\n      optional: false,\n      validate: assertNodeType(\"SelectionSet\")\n    },\n    name: {\n      optional: true,\n      validate: assertNodeType(\"Name\")\n    },\n    variableDefinitions: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"VariableDefinition\"))\n    },\n    directives: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"Directive\"))\n    }\n  },\n  aliases: [\"AST\", \"Definition\"]\n}], [\"VariableDefinition\", {\n  builder: [\"variable\", \"type\", \"defaultValue\"],\n  fields: {\n    variable: {\n      optional: false,\n      validate: assertNodeType(\"Variable\")\n    },\n    type: {\n      optional: false,\n      validate: assertNodeType(\"Type\")\n    },\n    defaultValue: {\n      optional: true,\n      validate: assertNodeType(\"Value\")\n    }\n  },\n  aliases: [\"AST\"]\n}], [\"Variable\", {\n  builder: [\"name\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    }\n  },\n  aliases: [\"AST\", \"Value\"]\n}], [\"SelectionSet\", {\n  builder: [\"selections\"],\n  fields: {\n    selections: {\n      optional: false,\n      validate: assertArrayOf(assertNodeType(\"Selection\"))\n    }\n  },\n  aliases: [\"AST\"]\n}], [\"Field\", {\n  builder: [\"name\", \"alias\", \"arguments\", \"directives\", \"selectionSet\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    },\n    alias: {\n      optional: true,\n      validate: assertNodeType(\"Name\")\n    },\n    arguments: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"Argument\"))\n    },\n    directives: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"Directive\"))\n    },\n    selectionSet: {\n      optional: true,\n      validate: assertNodeType(\"SelectionSet\")\n    }\n  },\n  aliases: [\"AST\", \"Selection\"]\n}], [\"Argument\", {\n  builder: [\"name\", \"value\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    },\n    value: {\n      optional: false,\n      validate: assertNodeType(\"Value\")\n    }\n  },\n  aliases: [\"AST\"]\n}], [\"FragmentSpread\", {\n  builder: [\"name\", \"directives\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    },\n    directives: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"Directive\"))\n    }\n  },\n  aliases: [\"AST\", \"Selection\"]\n}], [\"InlineFragment\", {\n  builder: [\"selectionSet\", \"typeCondition\", \"directives\"],\n  fields: {\n    selectionSet: {\n      optional: false,\n      validate: assertNodeType(\"SelectionSet\")\n    },\n    typeCondition: {\n      optional: true,\n      validate: assertNodeType(\"NamedType\")\n    },\n    directives: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"Directive\"))\n    }\n  },\n  aliases: [\"AST\", \"Selection\"]\n}], [\"FragmentDefinition\", {\n  builder: [\"name\", \"typeCondition\", \"selectionSet\", \"directives\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    },\n    typeCondition: {\n      optional: false,\n      validate: assertNodeType(\"NamedType\")\n    },\n    selectionSet: {\n      optional: false,\n      validate: assertNodeType(\"SelectionSet\")\n    },\n    directives: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"Directive\"))\n    }\n  },\n  aliases: [\"AST\", \"Definition\"]\n}], [\"IntValue\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      optional: false,\n      validate: assertValueType(\"string\")\n    }\n  },\n  aliases: [\"AST\", \"Value\"]\n}], [\"FloatValue\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      optional: false,\n      validate: assertValueType(\"string\")\n    }\n  },\n  aliases: [\"AST\", \"Value\"]\n}], [\"StringValue\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      optional: false,\n      validate: assertValueType(\"string\")\n    }\n  },\n  aliases: [\"AST\", \"Value\"]\n}], [\"BooleanValue\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      optional: false,\n      validate: assertValueType(\"boolean\")\n    }\n  },\n  aliases: [\"AST\", \"Value\"]\n}], [\"NullValue\", {\n  builder: [],\n  fields: {},\n  aliases: [\"AST\", \"Value\"]\n}], [\"EnumValue\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      optional: false,\n      validate: assertValueType(\"string\")\n    }\n  },\n  aliases: [\"AST\", \"Value\"]\n}], [\"ListValue\", {\n  builder: [\"values\"],\n  fields: {\n    values: {\n      optional: false,\n      validate: assertArrayOf(assertNodeType(\"Value\"))\n    }\n  },\n  aliases: [\"AST\", \"Value\"]\n}], [\"ObjectValue\", {\n  builder: [\"fields\"],\n  fields: {\n    fields: {\n      optional: false,\n      validate: assertArrayOf(assertNodeType(\"ObjectField\"))\n    }\n  },\n  aliases: [\"AST\", \"Value\"]\n}], [\"ObjectField\", {\n  builder: [\"name\", \"value\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    },\n    value: {\n      optional: false,\n      validate: assertNodeType(\"Value\")\n    }\n  },\n  aliases: [\"AST\"]\n}], [\"Directive\", {\n  builder: [\"name\", \"arguments\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    },\n    arguments: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"Argument\"))\n    }\n  },\n  aliases: [\"AST\"]\n}], [\"NamedType\", {\n  builder: [\"name\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    }\n  },\n  aliases: [\"AST\", \"Type\"]\n}], [\"ListType\", {\n  builder: [\"type\"],\n  fields: {\n    type: {\n      optional: false,\n      validate: assertNodeType(\"Type\")\n    }\n  },\n  aliases: [\"AST\", \"Type\"]\n}], [\"NonNullType\", {\n  builder: [\"type\"],\n  fields: {\n    type: {\n      optional: false,\n      validate: assertOneOf(\"NamedType\", \"ListType\")\n    }\n  },\n  aliases: [\"AST\", \"Type\"]\n}], [\"SchemaDefinition\", {\n  builder: [\"directives\", \"operationTypes\"],\n  fields: {\n    directives: {\n      optional: false,\n      validate: assertArrayOf(assertNodeType(\"Directive\"))\n    },\n    operationTypes: {\n      optional: false,\n      validate: assertArrayOf(assertNodeType(\"OperationTypeDefinition\"))\n    }\n  },\n  aliases: [\"AST\", \"TypeSystemDefinition\"]\n}], [\"OperationTypeDefinition\", {\n  builder: [\"operation\", \"type\"],\n  fields: {\n    operation: {\n      optional: false,\n      validate: assertValueType(\"string\")\n    },\n    type: {\n      optional: false,\n      validate: assertNodeType(\"NamedType\")\n    }\n  },\n  aliases: [\"AST\"]\n}], [\"ScalarTypeDefinition\", {\n  builder: [\"name\", \"directives\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    },\n    directives: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"Directive\"))\n    }\n  },\n  aliases: [\"AST\", \"TypeDefinition\"]\n}], [\"ObjectTypeDefinition\", {\n  builder: [\"name\", \"fields\", \"interfaces\", \"directives\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    },\n    fields: {\n      optional: false,\n      validate: assertArrayOf(assertNodeType(\"FieldDefinition\"))\n    },\n    interfaces: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"NamedType\"))\n    },\n    directives: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"Directive\"))\n    }\n  },\n  aliases: [\"AST\", \"TypeDefinition\"]\n}], [\"FieldDefinition\", {\n  builder: [\"name\", \"arguments\", \"type\", \"directives\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    },\n    arguments: {\n      optional: false,\n      validate: assertArrayOf(assertNodeType(\"InputValueDefinition\"))\n    },\n    type: {\n      optional: false,\n      validate: assertNodeType(\"Type\")\n    },\n    directives: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"Directive\"))\n    }\n  },\n  aliases: [\"AST\"]\n}], [\"InputValueDefinition\", {\n  builder: [\"name\", \"type\", \"defaultValue\", \"directives\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    },\n    type: {\n      optional: false,\n      validate: assertNodeType(\"Type\")\n    },\n    defaultValue: {\n      optional: true,\n      validate: assertNodeType(\"Value\")\n    },\n    directives: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"Directive\"))\n    }\n  },\n  aliases: [\"AST\"]\n}], [\"InterfaceTypeDefinition\", {\n  builder: [\"name\", \"fields\", \"directives\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    },\n    fields: {\n      optional: false,\n      validate: assertArrayOf(assertNodeType(\"FieldDefinition\"))\n    },\n    directives: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"Directive\"))\n    }\n  },\n  aliases: [\"AST\", \"TypeDefinition\"]\n}], [\"UnionTypeDefinition\", {\n  builder: [\"name\", \"types\", \"directives\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    },\n    types: {\n      optional: false,\n      validate: assertArrayOf(assertNodeType(\"NamedType\"))\n    },\n    directives: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"Directive\"))\n    }\n  },\n  aliases: [\"AST\", \"TypeDefinition\"]\n}], [\"EnumTypeDefinition\", {\n  builder: [\"name\", \"values\", \"directives\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    },\n    values: {\n      optional: false,\n      validate: assertArrayOf(assertNodeType(\"EnumValueDefinition\"))\n    },\n    directives: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"Directive\"))\n    }\n  },\n  aliases: [\"AST\", \"TypeDefinition\"]\n}], [\"EnumValueDefinition\", {\n  builder: [\"name\", \"directives\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    },\n    directives: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"Directive\"))\n    }\n  },\n  aliases: [\"AST\"]\n}], [\"InputObjectTypeDefinition\", {\n  builder: [\"name\", \"fields\", \"directives\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    },\n    fields: {\n      optional: false,\n      validate: assertArrayOf(assertNodeType(\"InputValueDefinition\"))\n    },\n    directives: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"Directive\"))\n    }\n  },\n  aliases: [\"AST\", \"TypeDefinition\"]\n}], [\"TypeExtensionDefinition\", {\n  builder: [\"definition\"],\n  fields: {\n    definition: {\n      optional: false,\n      validate: assertNodeType(\"ObjectTypeDefinition\")\n    }\n  },\n  aliases: [\"AST\", \"TypeSystemDefinition\"]\n}], [\"DirectiveDefinition\", {\n  builder: [\"name\", \"locations\", \"arguments\"],\n  fields: {\n    name: {\n      optional: false,\n      validate: assertNodeType(\"Name\")\n    },\n    locations: {\n      optional: false,\n      validate: assertArrayOf(assertNodeType(\"Name\"))\n    },\n    arguments: {\n      optional: true,\n      validate: assertArrayOf(assertNodeType(\"InputValueDefinition\"))\n    }\n  },\n  aliases: [\"AST\", \"TypeSystemDefinition\"]\n}]];", "import defineType from \"./index\";\nimport graphqlDef from \"./graphql\";\n\ngraphqlDef().forEach(([name, params]) => defineType(name, params));\n", "// @flow\n\nrequire('./definitions/init');\n\nconst { ALIAS_KEYS, NODE_FIELDS, BUILDER_KEYS } = require('./definitions');\n\nconst t = exports; // Maps all exports to t\n\n/**\n * Registers `is[Type]` and `assert[Type]` generated functions for a given `type`.\n * Pass `skipAliasCheck` to force it to directly compare `node.type` with `type`.\n */\n\nfunction registerType(type: string) {\n  const key = `is${type}`;\n\n  const _isType = t[key] !== undefined\n    ? t[key]\n    : t[key] = (node, opts) => t.is(type, node, opts);\n\n  t[`assert${type}`] = (node, opts = {}) => {\n    if (!_isType(node, opts)) {\n      throw new Error(`Expected type \"${type}\" with option ${JSON.stringify(opts)}`);\n    }\n  };\n}\n\nexport { ALIAS_KEYS, NODE_FIELDS, BUILDER_KEYS };\n\n/**\n * Registers `is[Type]` and `assert[Type]` for all types.\n */\n\nfor (const type in t.NODE_FIELDS) {\n  registerType(type);\n}\n\n/**\n * Flip `ALIAS_KEYS` for faster access in the reverse direction.\n */\n\nexport const TYPES = [];\n\nt.FLIPPED_ALIAS_KEYS = Object.keys(t.ALIAS_KEYS).reduce((acc, type) => {\n  const aliasKeys = t.ALIAS_KEYS[type];\n\n  aliasKeys.forEach(alias => {\n    if (acc[alias] === undefined) {\n      TYPES.push(alias); // Populate `TYPES` with FLIPPED_ALIAS_KEY(S)\n\n      // Registers `is[Alias]` and `assert[Alias]` functions for all aliases.\n      t[`${alias.toUpperCase()}_TYPES`] = acc[alias];\n      registerType(alias);\n\n      acc[alias] = [];\n    }\n\n    acc[alias].push(type);\n  });\n\n  return acc;\n}, {});\n\n/**\n * Returns whether `node` is of given `type`.\n *\n * For better performance, use this instead of `is[Type]` when `type` is unknown.\n * Optionally, pass `skipAliasCheck` to directly compare `node.type` with `type`.\n */\n\nexport function is(type: string, node: Object, opts?: Object): boolean {\n  if (node === null || typeof node !== 'object') {\n    return false;\n  }\n\n  const matches = isType(node.kind, type);\n  if (!matches) {\n    return false;\n  }\n\n  if (typeof opts === 'undefined') {\n    return true;\n  } else {\n    return t.shallowEqual(node, opts);\n  }\n}\n\n/**\n * Test if a `nodeType` is a `targetType` or if `targetType` is an alias of `nodeType`.\n */\n\nexport function isType(nodeType: string, targetType: string): boolean {\n  if (nodeType === targetType) {\n    return true;\n  }\n\n  // This is a fast-path. If the test above failed, but an alias key is found, then the\n  // targetType was a primary node type, so there's no need to check the aliases.\n  if (t.ALIAS_KEYS[targetType]) {\n    return false;\n  }\n\n  const aliases: ?Array<string> = t.FLIPPED_ALIAS_KEYS[targetType];\n  if (aliases) {\n    if (aliases[0] === nodeType) {\n      return true;\n    }\n\n    for (const alias of aliases) {\n      if (nodeType === alias) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * For each call of #defineType, the following expression evalutates and generates\n * a builder function that validates incoming arguments and returns a valid AST node.\n */\n\nfor (const type in t.BUILDER_KEYS) {\n  const keys = t.BUILDER_KEYS[type];\n  const fields = t.NODE_FIELDS[type];\n\n  function builder(...args) {\n    if (args.length > keys.length) {\n      throw new Error(\n        `t.${type}: Too many arguments passed. Received ${args.length} but can receive ` +\n          `no more than ${keys.length}`\n      );\n    }\n\n    const node = keys.reduce(\n      (node, key, i) => {\n        node[key] = (args[i] === undefined ? fields[key].default : args[i]);\n        return node;\n      },\n      { kind: type }\n    );\n\n    for (const key in node) {\n      validate(node, key, node[key]);\n    }\n\n    return node;\n  }\n\n  t[type[0].toLowerCase() + type.slice(1)] = builder;\n}\n\n/**\n * Executes the field validators for a given node\n */\n\nexport function validate(node?: Object, key: string, val: any) {\n  if (node === null || typeof node !== 'object') {\n    return;\n  }\n\n  const fields = t.NODE_FIELDS[node.kind];\n  if (fields === undefined) {\n    return;\n  }\n\n  const field = fields[key];\n  if (field === undefined || field.validate === undefined) {\n    return;\n  }\n\n  if (field.optional && (val === undefined || val === null)) {\n    return;\n  }\n\n  field.validate(node, key, val);\n}\n\n/**\n * Test if an object is shallowly equal.\n */\n\nexport function shallowEqual(actual: Object, expected: Object): boolean {\n  for (const key in expected) {\n    if (expected.hasOwnProperty(key) && actual[key] !== expected[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import merge from 'lodash/merge';\nimport buildDataProvider, { BuildQueryFactory, Options } from 'ra-data-graphql';\nimport { DataProvider, Identifier } from 'ra-core';\n\nimport defaultBuildQuery from './buildQuery';\nconst defaultOptions = {\n    buildQuery: defaultBuildQuery,\n};\n\nexport const buildQuery = defaultBuildQuery;\n\nexport default (\n    options: Omit<Options, 'buildQuery'> & { buildQuery?: BuildQueryFactory }\n): Promise<DataProvider> => {\n    return buildDataProvider(merge({}, defaultOptions, options)).then(\n        defaultDataProvider => {\n            return {\n                ...defaultDataProvider,\n                // This provider does not support multiple deletions so instead we send multiple DELETE requests\n                // This can be optimized using the apollo-link-batch-http link\n                deleteMany: (resource, params) => {\n                    const { ids, ...otherParams } = params;\n                    return Promise.all(\n                        ids.map(id =>\n                            defaultDataProvider.delete(resource, {\n                                id,\n                                previousData: null,\n                                ...otherParams,\n                            })\n                        )\n                    ).then(results => {\n                        const data = results.reduce<Identifier[]>(\n                            (acc, { data }) => [...acc, data.id],\n                            []\n                        );\n\n                        return { data };\n                    });\n                },\n                // This provider does not support multiple deletions so instead we send multiple UPDATE requests\n                // This can be optimized using the apollo-link-batch-http link\n                updateMany: (resource, params) => {\n                    const { ids, data, ...otherParams } = params;\n                    return Promise.all(\n                        ids.map(id =>\n                            defaultDataProvider.update(resource, {\n                                id,\n                                data: data,\n                                previousData: null,\n                                ...otherParams,\n                            })\n                        )\n                    ).then(results => {\n                        const data = results.reduce<Identifier[]>(\n                            (acc, { data }) => [...acc, data.id],\n                            []\n                        );\n\n                        return { data };\n                    });\n                },\n            };\n        }\n    );\n};\n", "import {\n    IntrospectionType,\n    IntrospectionTypeRef,\n    IntrospectionNonNullTypeRef,\n    TypeKind,\n} from 'graphql';\n\n/**\n * Ensure we get the real type even if the root type is NON_NULL or LIST\n * @param {GraphQLType} type\n */\nconst getFinalType = (\n    type: IntrospectionType | IntrospectionNonNullTypeRef | IntrospectionTypeRef\n) => {\n    if (type.kind === TypeKind.NON_NULL || type.kind === TypeKind.LIST) {\n        return getFinalType(type.ofType);\n    }\n\n    return type;\n};\n\nexport default getFinalType;\n", "import {\n    IntrospectionType,\n    IntrospectionTypeRef,\n    IntrospectionNonNullTypeRef,\n    TypeKind,\n} from 'graphql';\n\nconst isList = (\n    type: IntrospectionType | IntrospectionNonNullTypeRef | IntrospectionTypeRef\n) => {\n    if (type.kind === TypeKind.NON_NULL) {\n        return isList(type.ofType);\n    }\n\n    return type.kind === TypeKind.LIST;\n};\n\nexport default isList;\n", "/* eslint-disable default-case */\nimport {\n    IntrospectionField,\n    IntrospectionInputObjectType,\n    IntrospectionNamedTypeRef,\n    IntrospectionNonNullTypeRef,\n    IntrospectionType,\n} from 'graphql';\nimport {\n    GET_LIST,\n    GET_ONE,\n    GET_MANY,\n    GET_MANY_REFERENCE,\n    CREATE,\n    UPDATE,\n    DELETE,\n} from 'ra-core';\nimport { IntrospectionResult, IntrospectedResource } from 'ra-data-graphql';\n\nimport getFinalType from './getFinalType';\nimport isList from './isList';\n\nexport default (introspectionResults: IntrospectionResult) => (\n    resource: IntrospectedResource,\n    raFetchMethod: string,\n    params: any,\n    queryType: IntrospectionField\n) => {\n    const preparedParams = prepareParams(\n        params,\n        queryType,\n        introspectionResults\n    );\n\n    switch (raFetchMethod) {\n        case GET_LIST: {\n            return buildGetListVariables(introspectionResults)(\n                resource,\n                raFetchMethod,\n                preparedParams\n            );\n        }\n        case GET_MANY:\n            return {\n                filter: { ids: preparedParams.ids },\n            };\n        case GET_MANY_REFERENCE: {\n            let variables = buildGetListVariables(introspectionResults)(\n                resource,\n                raFetchMethod,\n                preparedParams\n            );\n\n            variables.filter = {\n                ...variables.filter,\n                [preparedParams.target]: preparedParams.id,\n            };\n\n            return variables;\n        }\n        case GET_ONE:\n        case DELETE:\n            return {\n                id: preparedParams.id,\n            };\n        case CREATE:\n        case UPDATE: {\n            return buildCreateUpdateVariables(\n                resource,\n                raFetchMethod,\n                preparedParams,\n                queryType\n            );\n        }\n    }\n};\n\nconst sanitizeValue = (type: IntrospectionType, value: any) => {\n    if (type.name === 'Int') {\n        return parseInt(value, 10);\n    }\n\n    if (type.name === 'Float') {\n        return parseFloat(value);\n    }\n\n    return value;\n};\n\nconst castType = (\n    value: any,\n    type: IntrospectionType | IntrospectionNonNullTypeRef\n) => {\n    const realType = type.kind === 'NON_NULL' ? type.ofType : type;\n    switch (\n        `${realType.kind}:${(realType as IntrospectionNamedTypeRef).name}`\n    ) {\n        case 'SCALAR:Int':\n            return Number(value);\n\n        case 'SCALAR:String':\n            return String(value);\n\n        case 'SCALAR:Boolean':\n            return Boolean(value);\n\n        default:\n            return value;\n    }\n};\n\nconst prepareParams = (\n    params: any,\n    queryType: Partial<IntrospectionField>,\n    introspectionResults: IntrospectionResult\n) => {\n    const result = {};\n\n    if (!params) {\n        return params;\n    }\n\n    Object.keys(params).forEach(key => {\n        const param = params[key];\n        let arg = null;\n\n        if (!param) {\n            result[key] = param;\n            return;\n        }\n\n        if (queryType && Array.isArray(queryType.args)) {\n            arg = queryType.args.find(item => item.name === key);\n        }\n\n        if (param instanceof File) {\n            result[key] = param;\n            return;\n        }\n\n        if (param instanceof Date) {\n            result[key] = param.toISOString();\n            return;\n        }\n\n        if (\n            param instanceof Object &&\n            !Array.isArray(param) &&\n            arg &&\n            arg.type.kind === 'INPUT_OBJECT'\n        ) {\n            const args = (introspectionResults.types.find(\n                item =>\n                    item.kind === arg.type.kind && item.name === arg.type.name\n            ) as IntrospectionInputObjectType).inputFields;\n            result[key] = prepareParams(param, { args }, introspectionResults);\n            return;\n        }\n\n        if (\n            param instanceof Object &&\n            !(param instanceof Date) &&\n            !Array.isArray(param)\n        ) {\n            result[key] = prepareParams(param, queryType, introspectionResults);\n            return;\n        }\n\n        if (!arg) {\n            result[key] = param;\n            return;\n        }\n\n        result[key] = castType(param, arg.type);\n    });\n\n    return result;\n};\n\nconst buildGetListVariables = (introspectionResults: IntrospectionResult) => (\n    resource: IntrospectedResource,\n    raFetchMethod: string,\n    params: any\n) => {\n    let variables: Partial<{\n        filter: { [key: string]: any };\n        page: number;\n        perPage: number;\n        sortField: string;\n        sortOrder: string;\n    }> = { filter: {} };\n    if (params.filter) {\n        variables.filter = Object.keys(params.filter).reduce((acc, key) => {\n            if (key === 'ids') {\n                return { ...acc, ids: params.filter[key] };\n            }\n\n            if (typeof params.filter[key] === 'object') {\n                const type = introspectionResults.types.find(\n                    t => t.name === `${resource.type.name}Filter`\n                );\n                const filterSome = (type as IntrospectionInputObjectType)?.inputFields?.find(\n                    t => t.name === `${key}_some`\n                );\n\n                if (filterSome) {\n                    const filter = Object.keys(params.filter[key]).reduce(\n                        (acc, k) => ({\n                            ...acc,\n                            [`${k}_in`]: params.filter[key][k],\n                        }),\n                        {}\n                    );\n                    return { ...acc, [`${key}_some`]: filter };\n                }\n            }\n\n            const parts = key.split('.');\n\n            if (parts.length > 1) {\n                if (parts[1] === 'id') {\n                    const type = introspectionResults.types.find(\n                        t => t.name === `${resource.type.name}Filter`\n                    );\n                    const filterSome = (type as IntrospectionInputObjectType)?.inputFields?.find(\n                        t => t.name === `${parts[0]}_some`\n                    );\n\n                    if (filterSome) {\n                        return {\n                            ...acc,\n                            [`${parts[0]}_some`]: { id: params.filter[key] },\n                        };\n                    }\n\n                    return { ...acc, [parts[0]]: { id: params.filter[key] } };\n                }\n\n                const resourceField = resource.type.fields.find(\n                    f => f.name === parts[0]\n                );\n                const type = getFinalType(resourceField.type);\n                return {\n                    ...acc,\n                    [key]: sanitizeValue(type, params.filter[key]),\n                };\n            }\n\n            const resourceField = resource.type.fields.find(\n                f => f.name === key\n            );\n\n            if (resourceField) {\n                const type = getFinalType(resourceField.type);\n                const isAList = isList(resourceField.type);\n\n                if (isAList) {\n                    return {\n                        ...acc,\n                        [key]: Array.isArray(params.filter[key])\n                            ? params.filter[key].map(value =>\n                                  sanitizeValue(type, value)\n                              )\n                            : sanitizeValue(type, [params.filter[key]]),\n                    };\n                }\n\n                return {\n                    ...acc,\n                    [key]: sanitizeValue(type, params.filter[key]),\n                };\n            }\n\n            return { ...acc, [key]: params.filter[key] };\n        }, {});\n    }\n\n    if (params.pagination) {\n        variables.page = parseInt(params.pagination.page, 10) - 1;\n        variables.perPage = parseInt(params.pagination.perPage, 10);\n    }\n\n    if (params.sort) {\n        variables.sortField = params.sort.field;\n        variables.sortOrder = params.sort.order;\n    }\n\n    return variables;\n};\n\nconst buildCreateUpdateVariables = (\n    resource: IntrospectedResource,\n    raFetchMethod,\n    { id, data }: any,\n    queryType: IntrospectionField\n) =>\n    Object.keys(data).reduce(\n        (acc, key) => {\n            if (Array.isArray(data[key])) {\n                const arg = queryType.args.find(a => a.name === `${key}Ids`);\n\n                if (arg) {\n                    return {\n                        ...acc,\n                        [`${key}Ids`]: data[key].map(({ id }) => id),\n                    };\n                }\n            }\n\n            if (typeof data[key] === 'object') {\n                const arg = queryType.args.find(a => a.name === `${key}Id`);\n\n                if (arg) {\n                    return {\n                        ...acc,\n                        [`${key}Id`]: data[key].id,\n                    };\n                }\n            }\n\n            return {\n                ...acc,\n                [key]: data[key],\n            };\n        },\n        { id }\n    );\n", "import { GET_LIST, GET_MANY, GET_MANY_REFERENCE, DELETE } from 'ra-core';\nimport {\n    QUERY_TYPES,\n    IntrospectionResult,\n    IntrospectedResource,\n} from 'ra-data-graphql';\nimport {\n    ArgumentNode,\n    IntrospectionField,\n    IntrospectionInputValue,\n    IntrospectionNamedTypeRef,\n    IntrospectionObjectType,\n    IntrospectionUnionType,\n    TypeKind,\n    TypeNode,\n    VariableDefinitionNode,\n} from 'graphql';\nimport * as gqlTypes from 'graphql-ast-types-browser';\n\nimport getFinalType from './getFinalType';\nimport isList from './isList';\nimport isRequired from './isRequired';\n\nexport default (introspectionResults: IntrospectionResult) => (\n    resource: IntrospectedResource,\n    raFetchMethod: string,\n    queryType: IntrospectionField,\n    variables: any\n) => {\n    const { sortField, sortOrder, ...metaVariables } = variables;\n    const apolloArgs = buildApolloArgs(queryType, variables);\n    const args = buildArgs(queryType, variables);\n    const metaArgs = buildArgs(queryType, metaVariables);\n    const fields = buildFields(introspectionResults)(resource.type.fields);\n\n    if (\n        raFetchMethod === GET_LIST ||\n        raFetchMethod === GET_MANY ||\n        raFetchMethod === GET_MANY_REFERENCE\n    ) {\n        return gqlTypes.document([\n            gqlTypes.operationDefinition(\n                'query',\n                gqlTypes.selectionSet([\n                    gqlTypes.field(\n                        gqlTypes.name(queryType.name),\n                        gqlTypes.name('items'),\n                        args,\n                        null,\n                        gqlTypes.selectionSet(fields)\n                    ),\n                    gqlTypes.field(\n                        gqlTypes.name(`_${queryType.name}Meta`),\n                        gqlTypes.name('total'),\n                        metaArgs,\n                        null,\n                        gqlTypes.selectionSet([\n                            gqlTypes.field(gqlTypes.name('count')),\n                        ])\n                    ),\n                ]),\n                gqlTypes.name(queryType.name),\n                apolloArgs\n            ),\n        ]);\n    }\n\n    if (raFetchMethod === DELETE) {\n        return gqlTypes.document([\n            gqlTypes.operationDefinition(\n                'mutation',\n                gqlTypes.selectionSet([\n                    gqlTypes.field(\n                        gqlTypes.name(queryType.name),\n                        gqlTypes.name('data'),\n                        args,\n                        null,\n                        gqlTypes.selectionSet(fields)\n                    ),\n                ]),\n                gqlTypes.name(queryType.name),\n                apolloArgs\n            ),\n        ]);\n    }\n\n    return gqlTypes.document([\n        gqlTypes.operationDefinition(\n            QUERY_TYPES.includes(raFetchMethod) ? 'query' : 'mutation',\n            gqlTypes.selectionSet([\n                gqlTypes.field(\n                    gqlTypes.name(queryType.name),\n                    gqlTypes.name('data'),\n                    args,\n                    null,\n                    gqlTypes.selectionSet(fields)\n                ),\n            ]),\n            gqlTypes.name(queryType.name),\n            apolloArgs\n        ),\n    ]);\n};\n\nexport const buildFields = (\n    introspectionResults: IntrospectionResult,\n    paths = []\n) => fields =>\n    fields.reduce((acc, field) => {\n        const type = getFinalType(field.type);\n\n        if (type.name.startsWith('_')) {\n            return acc;\n        }\n\n        if (type.kind !== TypeKind.OBJECT && type.kind !== TypeKind.INTERFACE) {\n            return [...acc, gqlTypes.field(gqlTypes.name(field.name))];\n        }\n\n        const linkedResource = introspectionResults.resources.find(\n            r => r.type.name === type.name\n        );\n\n        if (linkedResource) {\n            return [\n                ...acc,\n                gqlTypes.field(\n                    gqlTypes.name(field.name),\n                    null,\n                    null,\n                    null,\n                    gqlTypes.selectionSet([gqlTypes.field(gqlTypes.name('id'))])\n                ),\n            ];\n        }\n\n        const linkedType = introspectionResults.types.find(\n            t => t.name === type.name\n        );\n\n        if (linkedType && !paths.includes(linkedType.name)) {\n            const possibleTypes =\n                (linkedType as IntrospectionUnionType).possibleTypes || [];\n            return [\n                ...acc,\n                gqlTypes.field(\n                    gqlTypes.name(field.name),\n                    null,\n                    null,\n                    null,\n                    gqlTypes.selectionSet([\n                        ...buildFragments(introspectionResults)(possibleTypes),\n                        ...buildFields(introspectionResults, [\n                            ...paths,\n                            linkedType.name,\n                        ])((linkedType as IntrospectionObjectType).fields),\n                    ])\n                ),\n            ];\n        }\n\n        // NOTE: We might have to handle linked types which are not resources but will have to be careful about\n        // ending with endless circular dependencies\n        return acc;\n    }, []);\n\nexport const buildFragments = (introspectionResults: IntrospectionResult) => (\n    possibleTypes: readonly IntrospectionNamedTypeRef<IntrospectionObjectType>[]\n) =>\n    possibleTypes.reduce((acc, possibleType) => {\n        const type = getFinalType(possibleType);\n\n        const linkedType = introspectionResults.types.find(\n            t => t.name === type.name\n        );\n\n        return [\n            ...acc,\n            gqlTypes.inlineFragment(\n                gqlTypes.selectionSet(\n                    buildFields(introspectionResults)(\n                        (linkedType as IntrospectionObjectType).fields\n                    )\n                ),\n                gqlTypes.namedType(gqlTypes.name(type.name))\n            ),\n        ];\n    }, []);\n\nexport const buildArgs = (\n    query: IntrospectionField,\n    variables: any\n): ArgumentNode[] => {\n    if (query.args.length === 0) {\n        return [];\n    }\n\n    const validVariables = Object.keys(variables).filter(\n        k => typeof variables[k] !== 'undefined'\n    );\n    let args = query.args\n        .filter(a => validVariables.includes(a.name))\n        .reduce(\n            (acc, arg) => [\n                ...acc,\n                gqlTypes.argument(\n                    gqlTypes.name(arg.name),\n                    gqlTypes.variable(gqlTypes.name(arg.name))\n                ),\n            ],\n            []\n        );\n\n    return args;\n};\n\nexport const buildApolloArgs = (\n    query: IntrospectionField,\n    variables: any\n): VariableDefinitionNode[] => {\n    if (query.args.length === 0) {\n        return [];\n    }\n\n    const validVariables = Object.keys(variables).filter(\n        k => typeof variables[k] !== 'undefined'\n    );\n\n    let args = query.args\n        .filter(a => validVariables.includes(a.name))\n        .reduce((acc, arg) => {\n            return [\n                ...acc,\n                gqlTypes.variableDefinition(\n                    gqlTypes.variable(gqlTypes.name(arg.name)),\n                    getArgType(arg)\n                ),\n            ];\n        }, []);\n\n    return args;\n};\n\nexport const getArgType = (arg: IntrospectionInputValue): TypeNode => {\n    const type = getFinalType(arg.type);\n    const required = isRequired(arg.type);\n    const list = isList(arg.type);\n\n    if (list) {\n        if (required) {\n            return gqlTypes.listType(\n                gqlTypes.nonNullType(\n                    gqlTypes.namedType(gqlTypes.name(type.name))\n                )\n            );\n        }\n        return gqlTypes.listType(gqlTypes.namedType(gqlTypes.name(type.name)));\n    }\n\n    if (required) {\n        return gqlTypes.nonNullType(\n            gqlTypes.namedType(gqlTypes.name(type.name))\n        );\n    }\n\n    return gqlTypes.namedType(gqlTypes.name(type.name));\n};\n", "import {\n    IntrospectionType,\n    IntrospectionListTypeRef,\n    IntrospectionTypeRef,\n    TypeKind,\n} from 'graphql';\n\nconst isRequired = (\n    type: IntrospectionType | IntrospectionListTypeRef | IntrospectionTypeRef\n) => {\n    if (type.kind === TypeKind.LIST) {\n        return isRequired(type.ofType);\n    }\n\n    return type.kind === TypeKind.NON_NULL;\n};\n\nexport default isRequired;\n", "import { GET_LIST, GET_MANY, GET_MANY_REFERENCE } from 'ra-core';\nimport { IntrospectionResult, IntrospectedResource } from 'ra-data-graphql';\nimport { IntrospectionField } from 'graphql';\nimport { ApolloQueryResult } from '@apollo/client';\n\nexport default (_introspectionResults: IntrospectionResult) => (\n    raFetchMethod: string,\n    _resource: IntrospectedResource,\n    _queryType: IntrospectionField\n) => (response: ApolloQueryResult<any>) => {\n    const data = response.data;\n\n    if (\n        raFetchMethod === GET_LIST ||\n        raFetchMethod === GET_MANY ||\n        raFetchMethod === GET_MANY_REFERENCE\n    ) {\n        return {\n            data: response.data.items.map(sanitizeResource),\n            total: response.data.total.count,\n        };\n    }\n\n    return { data: sanitizeResource(data.data) };\n};\n\nconst sanitizeResource = (data: any) => {\n    const result = Object.keys(data).reduce((acc, key) => {\n        if (key.startsWith('_')) {\n            return acc;\n        }\n\n        const dataForKey = data[key];\n\n        if (dataForKey === null || dataForKey === undefined) {\n            return acc;\n        }\n\n        if (Array.isArray(dataForKey)) {\n            if (\n                typeof dataForKey[0] === 'object' &&\n                dataForKey[0] != null &&\n                // If there is no id, it's not a reference but an embedded array\n                dataForKey[0].id != null\n            ) {\n                return {\n                    ...acc,\n                    [key]: dataForKey.map(sanitizeResource),\n                    [`${key}Ids`]: dataForKey.map(d => d.id),\n                };\n            } else {\n                return { ...acc, [key]: dataForKey };\n            }\n        }\n\n        if (\n            typeof dataForKey === 'object' &&\n            dataForKey != null &&\n            // If there is no id, it's not a reference but an embedded object\n            dataForKey.id != null\n        ) {\n            return {\n                ...acc,\n                ...(dataForKey &&\n                    dataForKey.id && {\n                        [`${key}.id`]: dataForKey.id,\n                    }),\n                // We should only sanitize gql types, not objects\n                [key]: dataForKey.__typename\n                    ? sanitizeResource(dataForKey)\n                    : dataForKey,\n            };\n        }\n\n        return { ...acc, [key]: dataForKey };\n    }, {});\n\n    return result;\n};\n", "import { IntrospectionResult, BuildQuery } from 'ra-data-graphql';\nimport buildVariables from './buildVariables';\nimport buildGqlQuery from './buildGqlQuery';\nimport getResponseParser from './getResponseParser';\n\nexport const buildQueryFactory = (\n    buildVariablesImpl = buildVariables,\n    buildGqlQueryImpl = buildGqlQuery,\n    getResponseParserImpl = getResponseParser\n) => (introspectionResults: IntrospectionResult): BuildQuery => {\n    const knownResources = introspectionResults.resources.map(r => r.type.name);\n\n    const buildQuery: BuildQuery = (raFetchType, resourceName, params) => {\n        const resource = introspectionResults.resources.find(\n            r => r.type.name === resourceName\n        );\n\n        if (!resource) {\n            throw new Error(\n                `Unknown resource ${resourceName}. Make sure it has been declared on your server side schema. Known resources are ${knownResources.join(\n                    ', '\n                )}`\n            );\n        }\n\n        const queryType = resource[raFetchType];\n\n        if (!queryType) {\n            throw new Error(\n                `No query or mutation matching fetch type ${raFetchType} could be found for resource ${resource.type.name}`\n            );\n        }\n\n        const variables = buildVariablesImpl(introspectionResults)(\n            resource,\n            raFetchType,\n            params,\n            queryType\n        );\n        const query = buildGqlQueryImpl(introspectionResults)(\n            resource,\n            raFetchType,\n            queryType,\n            variables\n        );\n        const parseResponse = getResponseParserImpl(introspectionResults)(\n            raFetchType,\n            resource,\n            queryType\n        );\n\n        return {\n            query,\n            variables,\n            parseResponse,\n        };\n    };\n\n    return buildQuery;\n};\n\nexport default buildQueryFactory(\n    buildVariables,\n    buildGqlQuery,\n    getResponseParser\n);\n"],
  "mappings": "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",
  "names": ["defineType", "chain", "assertEach", "assertOneOf", "assertNodeType", "assertNodeOrValueType", "assertValueType", "assertArrayOf", "t", "require", "BUILDER_KEYS", "NODE_FIELDS", "ALIAS_KEYS", "type", "fields", "aliases", "builder", "key", "field", "indexOf", "optional", "getType", "val", "Array", "isArray", "undefined", "fns", "validate", "args", "forEach", "fn", "callback", "validator", "node", "it", "i", "vals", "kind", "TypeError", "JSON", "stringify", "types", "valid", "every", "is", "cb", "builder", "fields", "value", "optional", "validate", "aliases", "definitions", "operation", "selectionSet", "name", "variableDefinitions", "directives", "variable", "type", "defaultValue", "selections", "alias", "arguments", "typeCondition", "values", "operationTypes", "interfaces", "types", "definition", "locations", "forEach", "name", "params", "is", "isType", "validate", "shallowEqual", "require", "ALIAS_KEYS", "NODE_FIELDS", "BUILDER_KEYS", "t", "exports", "registerType", "type", "key", "_isType", "undefined", "node", "opts", "Error", "JSON", "stringify", "TYPES", "FLIPPED_ALIAS_KEYS", "Object", "keys", "reduce", "acc", "aliasKeys", "forEach", "alias", "push", "toUpperCase", "matches", "kind", "nodeType", "targetType", "aliases", "fields", "builder", "args", "length", "i", "default", "toLowerCase", "slice", "val", "field", "optional", "actual", "expected", "hasOwnProperty", "acc", "_a", "id", "field", "__assign", "buildQuery", "esm_default", "merge", "__assign", "__rest", "data", "__spreadArray"]
}
