import {
  QUERY_TYPES,
  esm_default
} from "./chunk-QTJIJ6MI.js";
import {
  CREATE,
  DELETE,
  GET_LIST,
  GET_MANY,
  GET_MANY_REFERENCE,
  GET_ONE,
  UPDATE,
  require_merge
} from "./chunk-JWMLWPKG.js";
import "./chunk-V24G3IIS.js";
import "./chunk-GYWC62UC.js";
import "./chunk-SGX6G7DU.js";
import {
  TypeKind
} from "./chunk-AB3SZ4KA.js";
import "./chunk-I5C2TNJM.js";
import "./chunk-HS5T2ZWL.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/graphql-ast-types-browser/lib/definitions/index.js
var require_definitions = __commonJS({
  "node_modules/graphql-ast-types-browser/lib/definitions/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = defineType;
    exports.chain = chain;
    exports.assertEach = assertEach;
    exports.assertOneOf = assertOneOf;
    exports.assertNodeType = assertNodeType;
    exports.assertNodeOrValueType = assertNodeOrValueType;
    exports.assertValueType = assertValueType;
    exports.assertArrayOf = assertArrayOf;
    var t = require_lib();
    var BUILDER_KEYS = exports.BUILDER_KEYS = {};
    var NODE_FIELDS = exports.NODE_FIELDS = {};
    var ALIAS_KEYS = exports.ALIAS_KEYS = {};
    function defineType(type) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$fields = _ref.fields, fields = _ref$fields === void 0 ? {} : _ref$fields, _ref$aliases = _ref.aliases, aliases = _ref$aliases === void 0 ? [] : _ref$aliases, _ref$builder = _ref.builder, builder = _ref$builder === void 0 ? [] : _ref$builder;
      for (var key in fields) {
        var field2 = fields[key];
        if (builder.indexOf(key) === -1) {
          field2.optional = true;
        }
      }
      BUILDER_KEYS[type] = builder;
      NODE_FIELDS[type] = fields;
      ALIAS_KEYS[type] = aliases;
    }
    function getType(val) {
      if (Array.isArray(val)) {
        return "array";
      } else if (val === null) {
        return "null";
      } else if (val === void 0) {
        return "undefined";
      } else {
        return typeof val === "undefined" ? "undefined" : _typeof(val);
      }
    }
    function chain() {
      for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
        fns[_key] = arguments[_key];
      }
      return function validate() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        fns.forEach(function(fn) {
          return fn.apply(void 0, args);
        });
      };
    }
    function assertEach(callback) {
      function validator(node, key, val) {
        if (!Array.isArray(val)) {
          return;
        }
        val.forEach(function(it, i) {
          return callback(node, key + "[" + i + "]", it);
        });
      }
      return validator;
    }
    function assertOneOf() {
      for (var _len3 = arguments.length, vals = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        vals[_key3] = arguments[_key3];
      }
      function validate(node, key, val) {
        if (vals.indexOf(val.kind) < 0) {
          throw new TypeError("Property " + key + " expected value to be one of " + JSON.stringify(vals) + " but got " + JSON.stringify(val));
        }
      }
      return validate;
    }
    function assertNodeType() {
      for (var _len4 = arguments.length, types = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        types[_key4] = arguments[_key4];
      }
      function validate(node, key, val) {
        var valid = types.every(function(type) {
          return t.is(type, val);
        });
        if (!valid) {
          throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + JSON.stringify(types) + " " + ("but instead got " + JSON.stringify(val && val.type)));
        }
      }
      return validate;
    }
    function assertNodeOrValueType() {
      for (var _len5 = arguments.length, types = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        types[_key5] = arguments[_key5];
      }
      function validate(node, key, val) {
        var valid = types.every(function(type) {
          return getType(val) === type || t.is(type, val);
        });
        if (!valid) {
          throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + JSON.stringify(types) + " " + ("but instead got " + JSON.stringify(val && val.type)));
        }
      }
      return validate;
    }
    function assertValueType(type) {
      function validate(node, key, val) {
        var valid = getType(val) === type;
        if (!valid) {
          throw new TypeError("Property " + key + " expected type of " + type + " but got " + getType(val));
        }
      }
      return validate;
    }
    function assertArrayOf(cb) {
      return chain(assertValueType("array"), assertEach(cb));
    }
  }
});

// node_modules/graphql-ast-types-browser/lib/definitions/graphql.js
var require_graphql = __commonJS({
  "node_modules/graphql-ast-types-browser/lib/definitions/graphql.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _index = require_definitions();
    exports.default = function() {
      return [["Name", {
        builder: ["value"],
        fields: {
          value: {
            optional: false,
            validate: (0, _index.assertValueType)("string")
          }
        },
        aliases: ["AST"]
      }], ["Document", {
        builder: ["definitions"],
        fields: {
          definitions: {
            optional: false,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Definition"))
          }
        },
        aliases: ["AST"]
      }], ["OperationDefinition", {
        builder: ["operation", "selectionSet", "name", "variableDefinitions", "directives"],
        fields: {
          operation: {
            optional: false,
            validate: (0, _index.assertValueType)("string")
          },
          selectionSet: {
            optional: false,
            validate: (0, _index.assertNodeType)("SelectionSet")
          },
          name: {
            optional: true,
            validate: (0, _index.assertNodeType)("Name")
          },
          variableDefinitions: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("VariableDefinition"))
          },
          directives: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Directive"))
          }
        },
        aliases: ["AST", "Definition"]
      }], ["VariableDefinition", {
        builder: ["variable", "type", "defaultValue"],
        fields: {
          variable: {
            optional: false,
            validate: (0, _index.assertNodeType)("Variable")
          },
          type: {
            optional: false,
            validate: (0, _index.assertNodeType)("Type")
          },
          defaultValue: {
            optional: true,
            validate: (0, _index.assertNodeType)("Value")
          }
        },
        aliases: ["AST"]
      }], ["Variable", {
        builder: ["name"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          }
        },
        aliases: ["AST", "Value"]
      }], ["SelectionSet", {
        builder: ["selections"],
        fields: {
          selections: {
            optional: false,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Selection"))
          }
        },
        aliases: ["AST"]
      }], ["Field", {
        builder: ["name", "alias", "arguments", "directives", "selectionSet"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          },
          alias: {
            optional: true,
            validate: (0, _index.assertNodeType)("Name")
          },
          arguments: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Argument"))
          },
          directives: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Directive"))
          },
          selectionSet: {
            optional: true,
            validate: (0, _index.assertNodeType)("SelectionSet")
          }
        },
        aliases: ["AST", "Selection"]
      }], ["Argument", {
        builder: ["name", "value"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          },
          value: {
            optional: false,
            validate: (0, _index.assertNodeType)("Value")
          }
        },
        aliases: ["AST"]
      }], ["FragmentSpread", {
        builder: ["name", "directives"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          },
          directives: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Directive"))
          }
        },
        aliases: ["AST", "Selection"]
      }], ["InlineFragment", {
        builder: ["selectionSet", "typeCondition", "directives"],
        fields: {
          selectionSet: {
            optional: false,
            validate: (0, _index.assertNodeType)("SelectionSet")
          },
          typeCondition: {
            optional: true,
            validate: (0, _index.assertNodeType)("NamedType")
          },
          directives: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Directive"))
          }
        },
        aliases: ["AST", "Selection"]
      }], ["FragmentDefinition", {
        builder: ["name", "typeCondition", "selectionSet", "directives"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          },
          typeCondition: {
            optional: false,
            validate: (0, _index.assertNodeType)("NamedType")
          },
          selectionSet: {
            optional: false,
            validate: (0, _index.assertNodeType)("SelectionSet")
          },
          directives: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Directive"))
          }
        },
        aliases: ["AST", "Definition"]
      }], ["IntValue", {
        builder: ["value"],
        fields: {
          value: {
            optional: false,
            validate: (0, _index.assertValueType)("string")
          }
        },
        aliases: ["AST", "Value"]
      }], ["FloatValue", {
        builder: ["value"],
        fields: {
          value: {
            optional: false,
            validate: (0, _index.assertValueType)("string")
          }
        },
        aliases: ["AST", "Value"]
      }], ["StringValue", {
        builder: ["value"],
        fields: {
          value: {
            optional: false,
            validate: (0, _index.assertValueType)("string")
          }
        },
        aliases: ["AST", "Value"]
      }], ["BooleanValue", {
        builder: ["value"],
        fields: {
          value: {
            optional: false,
            validate: (0, _index.assertValueType)("boolean")
          }
        },
        aliases: ["AST", "Value"]
      }], ["NullValue", {
        builder: [],
        fields: {},
        aliases: ["AST", "Value"]
      }], ["EnumValue", {
        builder: ["value"],
        fields: {
          value: {
            optional: false,
            validate: (0, _index.assertValueType)("string")
          }
        },
        aliases: ["AST", "Value"]
      }], ["ListValue", {
        builder: ["values"],
        fields: {
          values: {
            optional: false,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Value"))
          }
        },
        aliases: ["AST", "Value"]
      }], ["ObjectValue", {
        builder: ["fields"],
        fields: {
          fields: {
            optional: false,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("ObjectField"))
          }
        },
        aliases: ["AST", "Value"]
      }], ["ObjectField", {
        builder: ["name", "value"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          },
          value: {
            optional: false,
            validate: (0, _index.assertNodeType)("Value")
          }
        },
        aliases: ["AST"]
      }], ["Directive", {
        builder: ["name", "arguments"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          },
          arguments: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Argument"))
          }
        },
        aliases: ["AST"]
      }], ["NamedType", {
        builder: ["name"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          }
        },
        aliases: ["AST", "Type"]
      }], ["ListType", {
        builder: ["type"],
        fields: {
          type: {
            optional: false,
            validate: (0, _index.assertNodeType)("Type")
          }
        },
        aliases: ["AST", "Type"]
      }], ["NonNullType", {
        builder: ["type"],
        fields: {
          type: {
            optional: false,
            validate: (0, _index.assertOneOf)("NamedType", "ListType")
          }
        },
        aliases: ["AST", "Type"]
      }], ["SchemaDefinition", {
        builder: ["directives", "operationTypes"],
        fields: {
          directives: {
            optional: false,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Directive"))
          },
          operationTypes: {
            optional: false,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("OperationTypeDefinition"))
          }
        },
        aliases: ["AST", "TypeSystemDefinition"]
      }], ["OperationTypeDefinition", {
        builder: ["operation", "type"],
        fields: {
          operation: {
            optional: false,
            validate: (0, _index.assertValueType)("string")
          },
          type: {
            optional: false,
            validate: (0, _index.assertNodeType)("NamedType")
          }
        },
        aliases: ["AST"]
      }], ["ScalarTypeDefinition", {
        builder: ["name", "directives"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          },
          directives: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Directive"))
          }
        },
        aliases: ["AST", "TypeDefinition"]
      }], ["ObjectTypeDefinition", {
        builder: ["name", "fields", "interfaces", "directives"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          },
          fields: {
            optional: false,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("FieldDefinition"))
          },
          interfaces: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("NamedType"))
          },
          directives: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Directive"))
          }
        },
        aliases: ["AST", "TypeDefinition"]
      }], ["FieldDefinition", {
        builder: ["name", "arguments", "type", "directives"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          },
          arguments: {
            optional: false,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("InputValueDefinition"))
          },
          type: {
            optional: false,
            validate: (0, _index.assertNodeType)("Type")
          },
          directives: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Directive"))
          }
        },
        aliases: ["AST"]
      }], ["InputValueDefinition", {
        builder: ["name", "type", "defaultValue", "directives"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          },
          type: {
            optional: false,
            validate: (0, _index.assertNodeType)("Type")
          },
          defaultValue: {
            optional: true,
            validate: (0, _index.assertNodeType)("Value")
          },
          directives: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Directive"))
          }
        },
        aliases: ["AST"]
      }], ["InterfaceTypeDefinition", {
        builder: ["name", "fields", "directives"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          },
          fields: {
            optional: false,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("FieldDefinition"))
          },
          directives: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Directive"))
          }
        },
        aliases: ["AST", "TypeDefinition"]
      }], ["UnionTypeDefinition", {
        builder: ["name", "types", "directives"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          },
          types: {
            optional: false,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("NamedType"))
          },
          directives: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Directive"))
          }
        },
        aliases: ["AST", "TypeDefinition"]
      }], ["EnumTypeDefinition", {
        builder: ["name", "values", "directives"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          },
          values: {
            optional: false,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("EnumValueDefinition"))
          },
          directives: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Directive"))
          }
        },
        aliases: ["AST", "TypeDefinition"]
      }], ["EnumValueDefinition", {
        builder: ["name", "directives"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          },
          directives: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Directive"))
          }
        },
        aliases: ["AST"]
      }], ["InputObjectTypeDefinition", {
        builder: ["name", "fields", "directives"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          },
          fields: {
            optional: false,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("InputValueDefinition"))
          },
          directives: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Directive"))
          }
        },
        aliases: ["AST", "TypeDefinition"]
      }], ["TypeExtensionDefinition", {
        builder: ["definition"],
        fields: {
          definition: {
            optional: false,
            validate: (0, _index.assertNodeType)("ObjectTypeDefinition")
          }
        },
        aliases: ["AST", "TypeSystemDefinition"]
      }], ["DirectiveDefinition", {
        builder: ["name", "locations", "arguments"],
        fields: {
          name: {
            optional: false,
            validate: (0, _index.assertNodeType)("Name")
          },
          locations: {
            optional: false,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("Name"))
          },
          arguments: {
            optional: true,
            validate: (0, _index.assertArrayOf)((0, _index.assertNodeType)("InputValueDefinition"))
          }
        },
        aliases: ["AST", "TypeSystemDefinition"]
      }]];
    };
  }
});

// node_modules/graphql-ast-types-browser/lib/definitions/init.js
var require_init = __commonJS({
  "node_modules/graphql-ast-types-browser/lib/definitions/init.js"() {
    "use strict";
    var _slicedToArray = function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var _index = require_definitions();
    var _index2 = _interopRequireDefault(_index);
    var _graphql = require_graphql();
    var _graphql2 = _interopRequireDefault(_graphql);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    (0, _graphql2.default)().forEach(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), name2 = _ref2[0], params = _ref2[1];
      return (0, _index2.default)(name2, params);
    });
  }
});

// node_modules/graphql-ast-types-browser/lib/index.js
var require_lib = __commonJS({
  "node_modules/graphql-ast-types-browser/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.is = is;
    exports.isType = isType;
    exports.validate = validate;
    exports.shallowEqual = shallowEqual;
    require_init();
    var _require = require_definitions();
    var ALIAS_KEYS = _require.ALIAS_KEYS;
    var NODE_FIELDS = _require.NODE_FIELDS;
    var BUILDER_KEYS = _require.BUILDER_KEYS;
    var t = exports;
    function registerType(type2) {
      var key = "is" + type2;
      var _isType = t[key] !== void 0 ? t[key] : t[key] = function(node, opts) {
        return t.is(type2, node, opts);
      };
      t["assert" + type2] = function(node) {
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (!_isType(node, opts)) {
          throw new Error('Expected type "' + type2 + '" with option ' + JSON.stringify(opts));
        }
      };
    }
    exports.ALIAS_KEYS = ALIAS_KEYS;
    exports.NODE_FIELDS = NODE_FIELDS;
    exports.BUILDER_KEYS = BUILDER_KEYS;
    for (type in t.NODE_FIELDS) {
      registerType(type);
    }
    var type;
    var TYPES = exports.TYPES = [];
    t.FLIPPED_ALIAS_KEYS = Object.keys(t.ALIAS_KEYS).reduce(function(acc, type2) {
      var aliasKeys = t.ALIAS_KEYS[type2];
      aliasKeys.forEach(function(alias) {
        if (acc[alias] === void 0) {
          TYPES.push(alias);
          t[alias.toUpperCase() + "_TYPES"] = acc[alias];
          registerType(alias);
          acc[alias] = [];
        }
        acc[alias].push(type2);
      });
      return acc;
    }, {});
    function is(type2, node, opts) {
      if (node === null || (typeof node === "undefined" ? "undefined" : _typeof(node)) !== "object") {
        return false;
      }
      var matches = isType(node.kind, type2);
      if (!matches) {
        return false;
      }
      if (typeof opts === "undefined") {
        return true;
      } else {
        return t.shallowEqual(node, opts);
      }
    }
    function isType(nodeType, targetType) {
      if (nodeType === targetType) {
        return true;
      }
      if (t.ALIAS_KEYS[targetType]) {
        return false;
      }
      var aliases = t.FLIPPED_ALIAS_KEYS[targetType];
      if (aliases) {
        if (aliases[0] === nodeType) {
          return true;
        }
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = aliases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var alias = _step.value;
            if (nodeType === alias) {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      return false;
    }
    var _loop = function _loop2(_type2) {
      var keys = t.BUILDER_KEYS[_type2];
      var fields = t.NODE_FIELDS[_type2];
      function builder() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (args.length > keys.length) {
          throw new Error("t." + _type2 + ": Too many arguments passed. Received " + args.length + " but can receive " + ("no more than " + keys.length));
        }
        var node = keys.reduce(function(node2, key2, i) {
          node2[key2] = args[i] === void 0 ? fields[key2].default : args[i];
          return node2;
        }, { kind: _type2 });
        for (var key in node) {
          validate(node, key, node[key]);
        }
        return node;
      }
      t[_type2[0].toLowerCase() + _type2.slice(1)] = builder;
    };
    for (_type in t.BUILDER_KEYS) {
      _loop(_type);
    }
    var _type;
    function validate(node, key, val) {
      if (node === null || (typeof node === "undefined" ? "undefined" : _typeof(node)) !== "object") {
        return;
      }
      var fields = t.NODE_FIELDS[node.kind];
      if (fields === void 0) {
        return;
      }
      var field2 = fields[key];
      if (field2 === void 0 || field2.validate === void 0) {
        return;
      }
      if (field2.optional && (val === void 0 || val === null)) {
        return;
      }
      field2.validate(node, key, val);
    }
    function shallowEqual(actual, expected) {
      for (var key in expected) {
        if (expected.hasOwnProperty(key) && actual[key] !== expected[key]) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/ra-data-graphql-simple/dist/esm/index.js
var import_merge = __toESM(require_merge());

// node_modules/ra-data-graphql-simple/dist/esm/getFinalType.js
var getFinalType = function(type) {
  if (type.kind === TypeKind.NON_NULL || type.kind === TypeKind.LIST) {
    return getFinalType(type.ofType);
  }
  return type;
};
var getFinalType_default = getFinalType;

// node_modules/ra-data-graphql-simple/dist/esm/isList.js
var isList = function(type) {
  if (type.kind === TypeKind.NON_NULL) {
    return isList(type.ofType);
  }
  return type.kind === TypeKind.LIST;
};
var isList_default = isList;

// node_modules/ra-data-graphql-simple/dist/esm/buildVariables.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var buildVariables_default = function(introspectionResults) {
  return function(resource, raFetchMethod, params, queryType) {
    var _a;
    var preparedParams = prepareParams(params, queryType, introspectionResults);
    switch (raFetchMethod) {
      case GET_LIST: {
        return buildGetListVariables(introspectionResults)(resource, raFetchMethod, preparedParams);
      }
      case GET_MANY:
        return {
          filter: { ids: preparedParams.ids }
        };
      case GET_MANY_REFERENCE: {
        var variables = buildGetListVariables(introspectionResults)(resource, raFetchMethod, preparedParams);
        variables.filter = __assign(__assign({}, variables.filter), (_a = {}, _a[preparedParams.target] = preparedParams.id, _a));
        return variables;
      }
      case GET_ONE:
      case DELETE:
        return {
          id: preparedParams.id
        };
      case CREATE:
      case UPDATE: {
        return buildCreateUpdateVariables(resource, raFetchMethod, preparedParams, queryType);
      }
    }
  };
};
var sanitizeValue = function(type, value) {
  if (type.name === "Int") {
    return parseInt(value, 10);
  }
  if (type.name === "Float") {
    return parseFloat(value);
  }
  return value;
};
var castType = function(value, type) {
  var realType = type.kind === "NON_NULL" ? type.ofType : type;
  switch ("".concat(realType.kind, ":").concat(realType.name)) {
    case "SCALAR:Int":
      return Number(value);
    case "SCALAR:String":
      return String(value);
    case "SCALAR:Boolean":
      return Boolean(value);
    default:
      return value;
  }
};
var prepareParams = function(params, queryType, introspectionResults) {
  var result = {};
  if (!params) {
    return params;
  }
  Object.keys(params).forEach(function(key) {
    var param = params[key];
    var arg = null;
    if (!param) {
      result[key] = param;
      return;
    }
    if (queryType && Array.isArray(queryType.args)) {
      arg = queryType.args.find(function(item) {
        return item.name === key;
      });
    }
    if (param instanceof File) {
      result[key] = param;
      return;
    }
    if (param instanceof Date) {
      result[key] = param.toISOString();
      return;
    }
    if (param instanceof Object && !Array.isArray(param) && arg && arg.type.kind === "INPUT_OBJECT") {
      var args = introspectionResults.types.find(function(item) {
        return item.kind === arg.type.kind && item.name === arg.type.name;
      }).inputFields;
      result[key] = prepareParams(param, { args }, introspectionResults);
      return;
    }
    if (param instanceof Object && !(param instanceof Date) && !Array.isArray(param)) {
      result[key] = prepareParams(param, queryType, introspectionResults);
      return;
    }
    if (!arg) {
      result[key] = param;
      return;
    }
    result[key] = castType(param, arg.type);
  });
  return result;
};
var buildGetListVariables = function(introspectionResults) {
  return function(resource, raFetchMethod, params) {
    var variables = { filter: {} };
    if (params.filter) {
      variables.filter = Object.keys(params.filter).reduce(function(acc, key) {
        var _a, _b, _c, _d, _e, _f, _g;
        var _h, _j;
        if (key === "ids") {
          return __assign(__assign({}, acc), { ids: params.filter[key] });
        }
        if (typeof params.filter[key] === "object") {
          var type = introspectionResults.types.find(function(t) {
            return t.name === "".concat(resource.type.name, "Filter");
          });
          var filterSome = (_h = type === null || type === void 0 ? void 0 : type.inputFields) === null || _h === void 0 ? void 0 : _h.find(function(t) {
            return t.name === "".concat(key, "_some");
          });
          if (filterSome) {
            var filter = Object.keys(params.filter[key]).reduce(function(acc2, k) {
              var _a2;
              return __assign(__assign({}, acc2), (_a2 = {}, _a2["".concat(k, "_in")] = params.filter[key][k], _a2));
            }, {});
            return __assign(__assign({}, acc), (_a = {}, _a["".concat(key, "_some")] = filter, _a));
          }
        }
        var parts = key.split(".");
        if (parts.length > 1) {
          if (parts[1] === "id") {
            var type_1 = introspectionResults.types.find(function(t) {
              return t.name === "".concat(resource.type.name, "Filter");
            });
            var filterSome = (_j = type_1 === null || type_1 === void 0 ? void 0 : type_1.inputFields) === null || _j === void 0 ? void 0 : _j.find(function(t) {
              return t.name === "".concat(parts[0], "_some");
            });
            if (filterSome) {
              return __assign(__assign({}, acc), (_b = {}, _b["".concat(parts[0], "_some")] = { id: params.filter[key] }, _b));
            }
            return __assign(__assign({}, acc), (_c = {}, _c[parts[0]] = { id: params.filter[key] }, _c));
          }
          var resourceField_1 = resource.type.fields.find(function(f) {
            return f.name === parts[0];
          });
          var type = getFinalType_default(resourceField_1.type);
          return __assign(__assign({}, acc), (_d = {}, _d[key] = sanitizeValue(type, params.filter[key]), _d));
        }
        var resourceField = resource.type.fields.find(function(f) {
          return f.name === key;
        });
        if (resourceField) {
          var type_2 = getFinalType_default(resourceField.type);
          var isAList = isList_default(resourceField.type);
          if (isAList) {
            return __assign(__assign({}, acc), (_e = {}, _e[key] = Array.isArray(params.filter[key]) ? params.filter[key].map(function(value) {
              return sanitizeValue(type_2, value);
            }) : sanitizeValue(type_2, [params.filter[key]]), _e));
          }
          return __assign(__assign({}, acc), (_f = {}, _f[key] = sanitizeValue(type_2, params.filter[key]), _f));
        }
        return __assign(__assign({}, acc), (_g = {}, _g[key] = params.filter[key], _g));
      }, {});
    }
    if (params.pagination) {
      variables.page = parseInt(params.pagination.page, 10) - 1;
      variables.perPage = parseInt(params.pagination.perPage, 10);
    }
    if (params.sort) {
      variables.sortField = params.sort.field;
      variables.sortOrder = params.sort.order;
    }
    return variables;
  };
};
var buildCreateUpdateVariables = function(resource, raFetchMethod, _a, queryType) {
  var id = _a.id, data = _a.data;
  return Object.keys(data).reduce(function(acc, key) {
    var _a2, _b, _c;
    if (Array.isArray(data[key])) {
      var arg = queryType.args.find(function(a) {
        return a.name === "".concat(key, "Ids");
      });
      if (arg) {
        return __assign(__assign({}, acc), (_a2 = {}, _a2["".concat(key, "Ids")] = data[key].map(function(_a3) {
          var id2 = _a3.id;
          return id2;
        }), _a2));
      }
    }
    if (typeof data[key] === "object") {
      var arg = queryType.args.find(function(a) {
        return a.name === "".concat(key, "Id");
      });
      if (arg) {
        return __assign(__assign({}, acc), (_b = {}, _b["".concat(key, "Id")] = data[key].id, _b));
      }
    }
    return __assign(__assign({}, acc), (_c = {}, _c[key] = data[key], _c));
  }, { id });
};

// node_modules/ra-data-graphql-simple/dist/esm/buildGqlQuery.js
var gqlTypes = __toESM(require_lib());

// node_modules/ra-data-graphql-simple/dist/esm/isRequired.js
var isRequired = function(type) {
  if (type.kind === TypeKind.LIST) {
    return isRequired(type.ofType);
  }
  return type.kind === TypeKind.NON_NULL;
};
var isRequired_default = isRequired;

// node_modules/ra-data-graphql-simple/dist/esm/buildGqlQuery.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var buildGqlQuery_default = function(introspectionResults) {
  return function(resource, raFetchMethod, queryType, variables) {
    var sortField = variables.sortField, sortOrder = variables.sortOrder, metaVariables = __rest(variables, ["sortField", "sortOrder"]);
    var apolloArgs = buildApolloArgs(queryType, variables);
    var args = buildArgs(queryType, variables);
    var metaArgs = buildArgs(queryType, metaVariables);
    var fields = buildFields(introspectionResults)(resource.type.fields);
    if (raFetchMethod === GET_LIST || raFetchMethod === GET_MANY || raFetchMethod === GET_MANY_REFERENCE) {
      return gqlTypes.document([
        gqlTypes.operationDefinition("query", gqlTypes.selectionSet([
          gqlTypes.field(gqlTypes.name(queryType.name), gqlTypes.name("items"), args, null, gqlTypes.selectionSet(fields)),
          gqlTypes.field(gqlTypes.name("_".concat(queryType.name, "Meta")), gqlTypes.name("total"), metaArgs, null, gqlTypes.selectionSet([
            gqlTypes.field(gqlTypes.name("count"))
          ]))
        ]), gqlTypes.name(queryType.name), apolloArgs)
      ]);
    }
    if (raFetchMethod === DELETE) {
      return gqlTypes.document([
        gqlTypes.operationDefinition("mutation", gqlTypes.selectionSet([
          gqlTypes.field(gqlTypes.name(queryType.name), gqlTypes.name("data"), args, null, gqlTypes.selectionSet(fields))
        ]), gqlTypes.name(queryType.name), apolloArgs)
      ]);
    }
    return gqlTypes.document([
      gqlTypes.operationDefinition(QUERY_TYPES.includes(raFetchMethod) ? "query" : "mutation", gqlTypes.selectionSet([
        gqlTypes.field(gqlTypes.name(queryType.name), gqlTypes.name("data"), args, null, gqlTypes.selectionSet(fields))
      ]), gqlTypes.name(queryType.name), apolloArgs)
    ]);
  };
};
var buildFields = function(introspectionResults, paths) {
  if (paths === void 0) {
    paths = [];
  }
  return function(fields) {
    return fields.reduce(function(acc, field2) {
      var type = getFinalType_default(field2.type);
      if (type.name.startsWith("_")) {
        return acc;
      }
      if (type.kind !== TypeKind.OBJECT && type.kind !== TypeKind.INTERFACE) {
        return __spreadArray(__spreadArray([], acc, true), [gqlTypes.field(gqlTypes.name(field2.name))], false);
      }
      var linkedResource = introspectionResults.resources.find(function(r) {
        return r.type.name === type.name;
      });
      if (linkedResource) {
        return __spreadArray(__spreadArray([], acc, true), [
          gqlTypes.field(gqlTypes.name(field2.name), null, null, null, gqlTypes.selectionSet([gqlTypes.field(gqlTypes.name("id"))]))
        ], false);
      }
      var linkedType = introspectionResults.types.find(function(t) {
        return t.name === type.name;
      });
      if (linkedType && !paths.includes(linkedType.name)) {
        var possibleTypes = linkedType.possibleTypes || [];
        return __spreadArray(__spreadArray([], acc, true), [
          gqlTypes.field(gqlTypes.name(field2.name), null, null, null, gqlTypes.selectionSet(__spreadArray(__spreadArray([], buildFragments(introspectionResults)(possibleTypes), true), buildFields(introspectionResults, __spreadArray(__spreadArray([], paths, true), [
            linkedType.name
          ], false))(linkedType.fields), true)))
        ], false);
      }
      return acc;
    }, []);
  };
};
var buildFragments = function(introspectionResults) {
  return function(possibleTypes) {
    return possibleTypes.reduce(function(acc, possibleType) {
      var type = getFinalType_default(possibleType);
      var linkedType = introspectionResults.types.find(function(t) {
        return t.name === type.name;
      });
      return __spreadArray(__spreadArray([], acc, true), [
        gqlTypes.inlineFragment(gqlTypes.selectionSet(buildFields(introspectionResults)(linkedType.fields)), gqlTypes.namedType(gqlTypes.name(type.name)))
      ], false);
    }, []);
  };
};
var buildArgs = function(query, variables) {
  if (query.args.length === 0) {
    return [];
  }
  var validVariables = Object.keys(variables).filter(function(k) {
    return typeof variables[k] !== "undefined";
  });
  var args = query.args.filter(function(a) {
    return validVariables.includes(a.name);
  }).reduce(function(acc, arg) {
    return __spreadArray(__spreadArray([], acc, true), [
      gqlTypes.argument(gqlTypes.name(arg.name), gqlTypes.variable(gqlTypes.name(arg.name)))
    ], false);
  }, []);
  return args;
};
var buildApolloArgs = function(query, variables) {
  if (query.args.length === 0) {
    return [];
  }
  var validVariables = Object.keys(variables).filter(function(k) {
    return typeof variables[k] !== "undefined";
  });
  var args = query.args.filter(function(a) {
    return validVariables.includes(a.name);
  }).reduce(function(acc, arg) {
    return __spreadArray(__spreadArray([], acc, true), [
      gqlTypes.variableDefinition(gqlTypes.variable(gqlTypes.name(arg.name)), getArgType(arg))
    ], false);
  }, []);
  return args;
};
var getArgType = function(arg) {
  var type = getFinalType_default(arg.type);
  var required = isRequired_default(arg.type);
  var list = isList_default(arg.type);
  if (list) {
    if (required) {
      return gqlTypes.listType(gqlTypes.nonNullType(gqlTypes.namedType(gqlTypes.name(type.name))));
    }
    return gqlTypes.listType(gqlTypes.namedType(gqlTypes.name(type.name)));
  }
  if (required) {
    return gqlTypes.nonNullType(gqlTypes.namedType(gqlTypes.name(type.name)));
  }
  return gqlTypes.namedType(gqlTypes.name(type.name));
};

// node_modules/ra-data-graphql-simple/dist/esm/getResponseParser.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var getResponseParser_default = function(_introspectionResults) {
  return function(raFetchMethod, _resource, _queryType) {
    return function(response) {
      var data = response.data;
      if (raFetchMethod === GET_LIST || raFetchMethod === GET_MANY || raFetchMethod === GET_MANY_REFERENCE) {
        return {
          data: response.data.items.map(sanitizeResource),
          total: response.data.total.count
        };
      }
      return { data: sanitizeResource(data.data) };
    };
  };
};
var sanitizeResource = function(data) {
  var result = Object.keys(data).reduce(function(acc, key) {
    var _a, _b, _c, _d, _e;
    if (key.startsWith("_")) {
      return acc;
    }
    var dataForKey = data[key];
    if (dataForKey === null || dataForKey === void 0) {
      return acc;
    }
    if (Array.isArray(dataForKey)) {
      if (typeof dataForKey[0] === "object" && dataForKey[0] != null && // If there is no id, it's not a reference but an embedded array
      dataForKey[0].id != null) {
        return __assign2(__assign2({}, acc), (_a = {}, _a[key] = dataForKey.map(sanitizeResource), _a["".concat(key, "Ids")] = dataForKey.map(function(d) {
          return d.id;
        }), _a));
      } else {
        return __assign2(__assign2({}, acc), (_b = {}, _b[key] = dataForKey, _b));
      }
    }
    if (typeof dataForKey === "object" && dataForKey != null && // If there is no id, it's not a reference but an embedded object
    dataForKey.id != null) {
      return __assign2(__assign2(__assign2({}, acc), dataForKey && dataForKey.id && (_c = {}, _c["".concat(key, ".id")] = dataForKey.id, _c)), (_d = {}, _d[key] = dataForKey.__typename ? sanitizeResource(dataForKey) : dataForKey, _d));
    }
    return __assign2(__assign2({}, acc), (_e = {}, _e[key] = dataForKey, _e));
  }, {});
  return result;
};

// node_modules/ra-data-graphql-simple/dist/esm/buildQuery.js
var buildQueryFactory = function(buildVariablesImpl, buildGqlQueryImpl, getResponseParserImpl) {
  if (buildVariablesImpl === void 0) {
    buildVariablesImpl = buildVariables_default;
  }
  if (buildGqlQueryImpl === void 0) {
    buildGqlQueryImpl = buildGqlQuery_default;
  }
  if (getResponseParserImpl === void 0) {
    getResponseParserImpl = getResponseParser_default;
  }
  return function(introspectionResults) {
    var knownResources = introspectionResults.resources.map(function(r) {
      return r.type.name;
    });
    var buildQuery2 = function(raFetchType, resourceName, params) {
      var resource = introspectionResults.resources.find(function(r) {
        return r.type.name === resourceName;
      });
      if (!resource) {
        throw new Error("Unknown resource ".concat(resourceName, ". Make sure it has been declared on your server side schema. Known resources are ").concat(knownResources.join(", ")));
      }
      var queryType = resource[raFetchType];
      if (!queryType) {
        throw new Error("No query or mutation matching fetch type ".concat(raFetchType, " could be found for resource ").concat(resource.type.name));
      }
      var variables = buildVariablesImpl(introspectionResults)(resource, raFetchType, params, queryType);
      var query = buildGqlQueryImpl(introspectionResults)(resource, raFetchType, queryType, variables);
      var parseResponse = getResponseParserImpl(introspectionResults)(raFetchType, resource, queryType);
      return {
        query,
        variables,
        parseResponse
      };
    };
    return buildQuery2;
  };
};
var buildQuery_default = buildQueryFactory(buildVariables_default, buildGqlQuery_default, getResponseParser_default);

// node_modules/ra-data-graphql-simple/dist/esm/index.js
var __assign3 = function() {
  __assign3 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var defaultOptions = {
  buildQuery: buildQuery_default
};
var buildQuery = buildQuery_default;
var esm_default2 = function(options) {
  return esm_default((0, import_merge.default)({}, defaultOptions, options)).then(function(defaultDataProvider) {
    return __assign3(__assign3({}, defaultDataProvider), {
      // This provider does not support multiple deletions so instead we send multiple DELETE requests
      // This can be optimized using the apollo-link-batch-http link
      deleteMany: function(resource, params) {
        var ids = params.ids, otherParams = __rest2(params, ["ids"]);
        return Promise.all(ids.map(function(id) {
          return defaultDataProvider.delete(resource, __assign3({ id, previousData: null }, otherParams));
        })).then(function(results) {
          var data = results.reduce(function(acc, _a) {
            var data2 = _a.data;
            return __spreadArray2(__spreadArray2([], acc, true), [data2.id], false);
          }, []);
          return { data };
        });
      },
      // This provider does not support multiple deletions so instead we send multiple UPDATE requests
      // This can be optimized using the apollo-link-batch-http link
      updateMany: function(resource, params) {
        var ids = params.ids, data = params.data, otherParams = __rest2(params, ["ids", "data"]);
        return Promise.all(ids.map(function(id) {
          return defaultDataProvider.update(resource, __assign3({ id, data, previousData: null }, otherParams));
        })).then(function(results) {
          var data2 = results.reduce(function(acc, _a) {
            var data3 = _a.data;
            return __spreadArray2(__spreadArray2([], acc, true), [data3.id], false);
          }, []);
          return { data: data2 };
        });
      }
    });
  });
};
export {
  buildQuery,
  esm_default2 as default
};
//# sourceMappingURL=ra-data-graphql-simple.js.map
